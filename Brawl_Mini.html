<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"/>
<title>Brawl Mini</title>
<style>
  :root{
    --bg:#111214; --canvas-bg:#222428; --wall:#444; --ui:#fff;
  }
  html,body{height:100%;margin:0;background:var(--bg);display:flex;align-items:center;justify-content:center;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Noto Sans KR',sans-serif;color:var(--ui);}
  #wrap{width:100%;height:100%;position:relative;overflow:hidden;}
  canvas{display:block;background:var(--canvas-bg);touch-action:none; border-radius:8px; margin:auto; width:100%; height:100%;}
  #ui{position:absolute;left:12px;top:12px;z-index:20}
  #ui .hp{background:rgba(255,255,255,0.06);padding:6px 10px;border-radius:10px}
  .hint{position:absolute;right:12px;top:12px;background:rgba(255,255,255,0.04);padding:6px 10px;border-radius:10px;font-size:13px}
</style>
</head>
<body>
  <div id="wrap">
    <div id="ui"><span class="hp">HP: <span id="hp">100</span></span></div>
    <div class="hint">ì™¼ìª½ ë“œë˜ê·¸: ì´ë™ â€¢ ì˜¤ë¥¸ìª½ ë“œë˜ê·¸ í›„ ë†“ê¸°: ë°œì‚¬</div>
    <canvas id="game"></canvas>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  // ê¸°ë³¸ ê°ì²´
  let W=innerWidth, H=innerHeight;
  function fitCanvas(){
    // ìº”ë²„ìŠ¤ë¥¼ ì‹¤ì œ ë Œë” í•´ìƒë„ë¡œ ë§ì¶˜ë‹¤ (CSS 100% ìœ ì§€)
    canvas.width = innerWidth;
    canvas.height = innerHeight;
    W = canvas.width; H = canvas.height;
  }
  fitCanvas();
  addEventListener('resize', () => {
    fitCanvas();
    generateWalls();
    placeEntitiesSafe();
  });

  // í”Œë ˆì´ì–´, ì 
  const player = { x:0, y:0, r:20, color:'#4f8cff', hp:100, bullets:[] };
  const enemy  = { x:0, y:0, r:20, color:'#ff6b6b', hp:50, alive:true, bullets:[], dirX:1, dirY:1 };

  // ë§µ(ë²½)
  let walls = [];

  function rectsOverlap(a,b){
    return !(a.x + a.width <= b.x || b.x + b.width <= a.x || a.y + a.height <= b.y || b.y + b.height <= a.y);
  }
  function circleIntersectsRect(cx,cy,cr,rect){
    // ê°€ê¹Œìš´ ì  ì°¾ê¸° (AABB-circle)
    const nx = Math.max(rect.x, Math.min(cx, rect.x + rect.width));
    const ny = Math.max(rect.y, Math.min(cy, rect.y + rect.height));
    const dx = nx - cx, dy = ny - cy;
    return (dx*dx + dy*dy) <= (cr*cr);
  }

  // ìë™ ë§µ ìƒì„±: í™”ë©´ì— ë¹„ë¡€í•´ ë²½ ìƒì„±, í”Œë ˆì´ì–´/ì ì´ ë²½ ë‚´ë¶€ì— ë“¤ì–´ê°€ì§€ ì•Šë„ë¡ ì¬ì‹œë„
  function generateWalls(){
    walls = [];
    const area = W * H;
    const approxCount = Math.max(2, Math.floor(area / 120000)); // í™”ë©´í¬ê¸° ë¹„ë¡€
    const attempts = approxCount * 6;
    for(let i=0;i<approxCount;i++){
      let tries = 0;
      while(tries++ < 30){
        const ww = Math.max(60, Math.random() * Math.min(W*0.25, 300));
        const hh = 18 + Math.random()*40;
        const x = Math.random() * (W - ww);
        const y = Math.random() * (H - hh);
        const candidate = { x, y, width: ww, height: hh };
        // ë„ˆë¬´ ì¤‘ì•™ì— ê¸¸ê²Œ ë§‰íˆì§€ ì•Šê²Œ ê°„ë‹¨ ê²€ì‚¬ (ë‹¤ë¥¸ ë²½ê³¼ ê²¹ì¹˜ì§€ ì•ŠëŠ”ì§€)
        let bad = false;
        for(const w of walls) if(rectsOverlap(w, candidate)) { bad = true; break; }
        if(!bad){ walls.push(candidate); break; }
      }
    }
  }

  // ì•ˆì „í•œ ìœ„ì¹˜ì— í”Œë ˆì´ì–´/ì  ë°°ì¹˜ (ë²½ê³¼ ê²¹ì¹˜ì§€ ì•Šê²Œ)
  function placeEntitiesSafe(){
    // player: ì•„ë˜ìª½ ì¤‘ì•™ ê·¼ì²˜
    const margin = 40;
    const triesMax = 200;
    // player
    for(let t=0;t<triesMax;t++){
      const px = W * (0.5 + (Math.random()-0.5)*0.2);
      const py = H * (0.7 + (Math.random()-0.5)*0.1);
      const inWall = walls.some(w => circleIntersectsRect(px,py,player.r+4,w));
      if(!inWall){ player.x = px; player.y = py; break; }
    }
    // enemy
    for(let t=0;t<triesMax;t++){
      const ex = W * (0.5 + (Math.random()-0.5)*0.2);
      const ey = H * (0.3 + (Math.random()-0.5)*0.1);
      const inWall = walls.some(w => circleIntersectsRect(ex,ey,enemy.r+4,w));
      const tooClose = Math.hypot(ex-player.x, ey-player.y) < 120;
      if(!inWall && !tooClose){ enemy.x = ex; enemy.y = ey; break; }
    }
  }

  generateWalls();
  placeEntitiesSafe();

  // ì…ë ¥ (ë“€ì–¼ìŠ¤í‹±)
  // ê°ê°: { id, sx, sy, x, y } or null
  let moveStick = null;
  let aimStick  = null;
  let moveVec = {x:0,y:0};
  let aimVec  = {x:0,y:0};
  let fireCooldownFrames = 0;

  // í„°ì¹˜ ì²˜ë¦¬
  canvas.addEventListener('touchstart', (ev) => {
    for(const t of ev.changedTouches){
      assignPointerStart(t.clientX, t.clientY, t.identifier);
    }
    ev.preventDefault();
  }, { passive:false });

  canvas.addEventListener('touchmove', (ev) => {
    for(const t of ev.changedTouches){
      updatePointerMove(t.clientX, t.clientY, t.identifier);
    }
    ev.preventDefault();
  }, { passive:false });

  canvas.addEventListener('touchend', (ev) => {
    for(const t of ev.changedTouches){
      handlePointerEnd(t.identifier);
    }
    ev.preventDefault();
  }, { passive:false });

  // ë§ˆìš°ìŠ¤(ë°ìŠ¤í¬íƒ‘) â€” í•˜ë‚˜ì˜ í¬ì¸í„°ë¡œ ê°„ë‹¨íˆ ì§€ì›
  let mousePointerId = 'mouse';
  let mouseDown = false;
  canvas.addEventListener('mousedown', (ev) => {
    mouseDown = true;
    assignPointerStart(ev.clientX, ev.clientY, mousePointerId);
  });
  window.addEventListener('mousemove', (ev) => {
    if(mouseDown) updatePointerMove(ev.clientX, ev.clientY, mousePointerId);
  });
  window.addEventListener('mouseup', (ev) => {
    if(mouseDown) handlePointerEnd(mousePointerId);
    mouseDown = false;
  });

  function assignPointerStart(x,y id){
    // split by screen half:
  }
  // fix: accidental syntax error â€” implement assignPointerStart properly below
  function assignPointerStart(x,y,id){
    if(x < W/2 && !moveStick){
      moveStick = { id, sx:x, sy:y, x, y };
      moveVec = {x:0,y:0};
    } else if(x >= W/2 && !aimStick){
      aimStick = { id, sx:x, sy:y, x, y };
      aimVec = {x:0,y:0};
    } else {
      // extra pointers ignored
    }
  }
  function updatePointerMove(x,y,id){
    if(moveStick && id === moveStick.id){
      const dx = x - moveStick.sx;
      const dy = y - moveStick.sy;
      const limit = Math.min(80, Math.max(40, Math.min(W,H)*0.06));
      const dist = Math.hypot(dx,dy);
      const ratio = dist > limit ? limit/dist : 1;
      moveStick.x = moveStick.sx + dx * ratio;
      moveStick.y = moveStick.sy + dy * ratio;
      moveVec = { x: (moveStick.x - moveStick.sx) / limit, y: (moveStick.y - moveStick.sy) / limit };
    } else if(aimStick && id === aimStick.id){
      const dx = x - aimStick.sx;
      const dy = y - aimStick.sy;
      const limit = Math.min(80, Math.max(40, Math.min(W,H)*0.06));
      const dist = Math.hypot(dx,dy);
      const ratio = dist > limit ? limit/dist : 1;
      aimStick.x = aimStick.sx + dx * ratio;
      aimStick.y = aimStick.sy + dy * ratio;
      aimVec = { x: (aimStick.x - aimStick.sx) / limit, y: (aimStick.y - aimStick.sy) / limit };
    }
  }
  function handlePointerEnd(id){
    // if ended aimStick -> fire in aimVec direction (if strong enough and cooldown)
    if(aimStick && id === aimStick.id){
      const magnitude = Math.hypot(aimVec.x, aimVec.y);
      if(magnitude > 0.25 && fireCooldownFrames <= 0){
        shoot(aimVec.x, aimVec.y);
        fireCooldownFrames = Math.max(6, Math.round(0.3 * 60)); // 0.3s @60fps
      }
      aimStick = null;
      aimVec = {x:0,y:0};
    }
    if(moveStick && id === moveStick.id){
      moveStick = null; moveVec = {x:0,y:0};
    }
  }

  // ì´ì•Œ ë°œì‚¬
  function shoot(dx,dy){
    const mag = Math.hypot(dx,dy);
    if(mag === 0) return;
    const angle = Math.atan2(dy,dx);
    const speed = 9;
    player.bullets.push({ x: player.x, y: player.y, dx: Math.cos(angle)*speed, dy: Math.sin(angle)*speed, r:5 });
  }

  // ì  ë°œì‚¬ (interval)
  setInterval(() => {
    if(!enemy.alive) return;
    const dx = player.x - enemy.x, dy = player.y - enemy.y;
    const a = Math.atan2(dy,dx);
    enemy.bullets.push({ x:enemy.x, y:enemy.y, dx: Math.cos(a)*4.2, dy: Math.sin(a)*4.2, r:5 });
  }, 1300);

  // ë²½ ì¶©ëŒ ì²˜ë¦¬ for circle (entity)
  function keepOutsideWalls(entity){
    // push out of walls by simple clamping â€” repeatedly adjust if inside
    for(let iter=0; iter<3; iter++){
      for(const w of walls){
        if(circleIntersectsRect(entity.x, entity.y, entity.r, w)){
          // compute minimal push vector: test four directions
          const cx = Math.max(w.x, Math.min(entity.x, w.x+w.width));
          const cy = Math.max(w.y, Math.min(entity.y, w.y+w.height));
          const dx = entity.x - cx;
          const dy = entity.y - cy;
          const d = Math.hypot(dx,dy) || 0.001;
          const overlap = entity.r - d;
          if(overlap > 0){
            entity.x += (dx/d) * overlap;
            entity.y += (dy/d) * overlap;
          }
        }
      }
    }
  }

  // ì´ì•Œ-ë²½ ì¶©ëŒ ê²€ì‚¬
  function bulletHitsWall(b){
    for(const w of walls){
      if(b.x > w.x && b.x < w.x + w.width && b.y > w.y && b.y < w.y + w.height) return true;
    }
    return false;
  }

  // ë¬¼ë¦¬/ê²Œì„ ë£¨í”„
  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }

  function update(){
    // ì´ë™
    const baseSpeed = Math.max(W,H) * 0.003;
    player.x += moveVec.x * baseSpeed * 5;
    player.y += moveVec.y * baseSpeed * 5;

    // enemy wandering simple
    if(enemy.alive){
      if(Math.random() < 0.012) { enemy.dirX *= -1; }
      if(Math.random() < 0.012) { enemy.dirY *= -1; }
      enemy.x += enemy.dirX * 1.6;
      enemy.y += enemy.dirY * 1.6;
    }

    // bounds
    player.x = clamp(player.x, player.r, W - player.r);
    player.y = clamp(player.y, player.r, H - player.r);
    enemy.x = clamp(enemy.x, enemy.r, W - enemy.r);
    enemy.y = clamp(enemy.y, enemy.r, H - enemy.r);

    // avoid walls
    keepOutsideWalls(player);
    keepOutsideWalls(enemy);

    // bullets move & collisions
    moveBullets(player.bullets);
    moveBullets(enemy.bullets);

    // bullets vs entities
    handleBulletHits();

    // cooldown
    if(fireCooldownFrames > 0) fireCooldownFrames--;

    draw();

    requestAnimationFrame(update);
  }

  function moveBullets(list){
    for(let i=list.length-1;i>=0;i--){
      const b = list[i];
      b.x += b.dx; b.y += b.dy;
      // remove if out of bounds or hit wall
      if(b.x < -50 || b.x > W+50 || b.y < -50 || b.y > H+50 || bulletHitsWall(b)){
        list.splice(i,1); continue;
      }
    }
  }

  function handleBulletHits(){
    // player bullets -> enemy
    for(let i=player.bullets.length-1;i>=0;i--){
      const b = player.bullets[i];
      if(enemy.alive && Math.hypot(b.x - enemy.x, b.y - enemy.y) < (b.r + enemy.r)){
        player.bullets.splice(i,1);
        enemy.hp -= 10;
        if(enemy.hp <= 0){ enemy.alive = false; setTimeout(()=>alert('ğŸ‰ ìŠ¹ë¦¬! ìƒˆë¡œê³ ì¹¨í•˜ë©´ ë‹¤ì‹œ ì‹œì‘í•©ë‹ˆë‹¤.'),80); }
      }
    }
    // enemy bullets -> player
    for(let i=enemy.bullets.length-1;i>=0;i--){
      const b = enemy.bullets[i];
      if(Math.hypot(b.x - player.x, b.y - player.y) < (b.r + player.r)){
        enemy.bullets.splice(i,1);
        player.hp -= 10;
        document.getElementById('hp').textContent = player.hp;
        if(player.hp <= 0){ setTimeout(()=>{ alert('ğŸ’€ íŒ¨ë°°! ìƒˆë¡œê³ ì¹¨í•˜ì„¸ìš”.'); location.reload(); },80); }
      }
    }
  }

  // ê·¸ë¦¬ê¸°
  function draw(){
    ctx.clearRect(0,0,W,H);

    // walls
    ctx.fillStyle = '#444';
    for(const w of walls){
      ctx.fillRect(Math.round(w.x), Math.round(w.y), Math.round(w.width), Math.round(w.height));
    }

    // enemy
    if(enemy.alive){
      ctx.fillStyle = enemy.color;
      ctx.beginPath(); ctx.arc(enemy.x, enemy.y, enemy.r, 0, Math.PI*2); ctx.fill();
      // hp bar
      ctx.fillStyle='#fff'; ctx.fillRect(enemy.x - 25, enemy.y - enemy.r - 18, 50, 6);
      ctx.fillStyle='#f33'; ctx.fillRect(enemy.x - 25, enemy.y - enemy.r - 18, 50 * Math.max(0, enemy.hp)/50, 6);
    }

    // player
    ctx.fillStyle = player.color;
    ctx.beginPath(); ctx.arc(player.x, player.y, player.r, 0, Math.PI*2); ctx.fill();

    // bullets
    ctx.fillStyle='#fff';
    for(const b of player.bullets){ ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill(); }
    ctx.fillStyle='#ffb3b3';
    for(const b of enemy.bullets){ ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill(); }

    // draw sticks if active
    if(moveStick){
      drawStickVisual(moveStick);
    }
    if(aimStick){
      drawStickVisual(aimStick);
    }

    // optional : draw cooldown indicator near right bottom
    if(fireCooldownFrames > 0){
      const perc = fireCooldownFrames / Math.max(1, Math.round(0.3*60));
      const x = W - 70, y = H - 70;
      ctx.globalAlpha = 0.5;
      ctx.beginPath(); ctx.arc(x,y,36,0,Math.PI*2); ctx.fillStyle='#444'; ctx.fill();
      ctx.globalAlpha = 1;
      ctx.beginPath(); ctx.arc(x,y,30,-Math.PI/2, -Math.PI/2 + Math.PI*2*(1-perc)); ctx.strokeStyle='#999'; ctx.lineWidth=6; ctx.stroke();
      ctx.fillStyle='#fff'; ctx.font='13px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText('CD', x, y);
    }
  }

  function drawStickVisual(s){
    ctx.globalAlpha = 0.35;
    ctx.fillStyle = '#888';
    ctx.beginPath(); ctx.arc(s.sx, s.sy, 44, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha = 0.95;
    ctx.fillStyle = '#ccc';
    ctx.beginPath(); ctx.arc(s.x, s.y, 28, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1;
  }

  // ìœ í‹¸
  function randRange(a,b){ return a + Math.random()*(b-a); }

  // ì‹œì‘
  update();

  // ì•ˆì „íˆ ì´ˆê¸°ê°’ ì„¸íŒ…: ë²½ ìƒì„± í›„ ë³´ì •
  // (ì´ë¯¸ í˜¸ì¶œ above)
})();
</script>
</body>
</html>
