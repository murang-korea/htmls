<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>Brawl Mini</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #222;
    touch-action: none;
  }
  canvas {
    display: block;
    background: #333;
  }
  .joystick {
    position: fixed;
    width: 120px;
    height: 120px;
    border-radius: 50%;
    background: rgba(255,255,255,0.1);
    border: 2px solid rgba(255,255,255,0.3);
    touch-action: none;
    z-index: 10;
  }
  .stick {
    position: absolute;
    width: 50px;
    height: 50px;
    background: rgba(255,255,255,0.3);
    border-radius: 50%;
    left: 35px;
    top: 35px;
  }
  #moveJoy { left: 30px; bottom: 30px; }
  #aimJoy { right: 30px; bottom: 30px; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="moveJoy" class="joystick"><div class="stick"></div></div>
<div id="aimJoy" class="joystick"><div class="stick"></div></div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let W = window.innerWidth, H = window.innerHeight;
canvas.width = W;
canvas.height = H;

// ===== 게임 데이터 =====
const player = { x: 0, y: 0, r: 20, hp: 100, reload: 0 };
const enemy = { x: 300, y: -400, r: 20, hp: 100, reload: 0 };
const bullets = [];
const eBullets = [];
const walls = [];
const mapW = 1200, mapH = 2000;
const speed = 3;
let moveVec = { x: 0, y: 0 };
let aimVec = { x: 0, y: 0 };
let gameOver = false;

// ===== 벽 일정 배치 =====
for (let i = 0; i < 10; i++) {
  for (let j = 0; j < 4; j++) {
    if ((i + j) % 2 === 0) {
      walls.push({
        x: -mapW / 2 + 150 * i,
        y: -mapH / 2 + 200 * j,
        w: 60,
        h: 60
      });
    }
  }
}

// ===== 조이스틱 =====
function setupJoystick(id, callback) {
  const joy = document.getElementById(id);
  const stick = joy.querySelector('.stick');
  let active = false,
    sx,
    sy;

  joy.addEventListener('touchstart', (e) => {
    e.preventDefault();
    active = true;
    sx = e.touches[0].clientX;
    sy = e.touches[0].clientY;
  });
  joy.addEventListener('touchmove', (e) => {
    if (!active) return;
    const dx = e.touches[0].clientX - sx;
    const dy = e.touches[0].clientY - sy;
    const dist = Math.min(40, Math.hypot(dx, dy));
    const ang = Math.atan2(dy, dx);
    stick.style.left = 35 + dist * Math.cos(ang) + 'px';
    stick.style.top = 35 + dist * Math.sin(ang) + 'px';
    callback(Math.cos(ang) * dist / 40, Math.sin(ang) * dist / 40);
  });
  joy.addEventListener('touchend', () => {
    active = false;
    stick.style.left = '35px';
    stick.style.top = '35px';
    callback(0, 0);
  });
}

setupJoystick('moveJoy', (x, y) => { moveVec = { x, y }; });
setupJoystick('aimJoy', (x, y) => { aimVec = { x, y }; });

// ===== 게임 루프 =====
function update() {
  if (gameOver) return;

  // 이동
  player.x += moveVec.x * speed;
  player.y += moveVec.y * speed;
  player.x = Math.max(-mapW/2 + player.r, Math.min(mapW/2 - player.r, player.x));
  player.y = Math.max(-mapH/2 + player.r, Math.min(mapH/2 - player.r, player.y));

  // 플레이어 발사
  if ((aimVec.x || aimVec.y) && player.reload <= 0) {
    bullets.push({
      x: player.x,
      y: player.y,
      dx: aimVec.x * 8,
      dy: aimVec.y * 8
    });
    player.reload = 20;
  }
  if (player.reload > 0) player.reload--;

  // 적 AI (기본 추적 + 사격)
  const dx = player.x - enemy.x;
  const dy = player.y - enemy.y;
  const dist = Math.hypot(dx, dy);
  if (dist > 150) {
    enemy.x += (dx / dist) * 1.2;
    enemy.y += (dy / dist) * 1.2;
  }
  if (enemy.reload <= 0) {
    eBullets.push({
      x: enemy.x,
      y: enemy.y,
      dx: (dx / dist) * 6,
      dy: (dy / dist) * 6
    });
    enemy.reload = 50;
  }
  if (enemy.reload > 0) enemy.reload--;

  // 총알 이동 및 충돌
  for (const b of bullets) {
    b.x += b.dx;
    b.y += b.dy;
    if (hit(enemy, b, enemy.r)) {
      enemy.hp -= 10;
      b.dead = true;
    }
    if (walls.some((w) => collideRect(b, w))) b.dead = true;
  }
  for (const b of eBullets) {
    b.x += b.dx;
    b.y += b.dy;
    if (hit(player, b, player.r)) {
      player.hp -= 10;
      b.dead = true;
    }
    if (walls.some((w) => collideRect(b, w))) b.dead = true;
  }

  // 총알 정리
  bullets.splice(0, bullets.length, ...bullets.filter((b) => !b.dead));
  eBullets.splice(0, eBullets.length, ...eBullets.filter((b) => !b.dead));

  // 승패 판정
  if (player.hp <= 0 || enemy.hp <= 0) {
    gameOver = true;
    setTimeout(() => alert(player.hp > 0 ? "승리!" : "패배..."), 300);
  }
}

// ===== 충돌 함수 =====
function hit(a, b, r) {
  return (a.x - b.x) ** 2 + (a.y - b.y) ** 2 < r ** 2;
}
function collideRect(b, w) {
  return (
    b.x > w.x - w.w / 2 &&
    b.x < w.x + w.w / 2 &&
    b.y > w.y - w.h / 2 &&
    b.y < w.y + w.h / 2
  );
}

// ===== 그리기 =====
function draw() {
  ctx.clearRect(0, 0, W, H);
  const camX = player.x, camY = player.y;
  ctx.save();
  ctx.translate(W / 2 - camX, H / 2 - camY);

  // 맵
  ctx.fillStyle = "#444";
  ctx.fillRect(-mapW / 2, -mapH / 2, mapW, mapH);

  // 벽
  ctx.fillStyle = "#666";
  for (const w of walls) {
    ctx.fillRect(w.x - w.w / 2, w.y - w.h / 2, w.w, w.h);
  }

  // 총알
  ctx.fillStyle = "yellow";
  for (const b of bullets) {
    ctx.beginPath();
    ctx.arc(b.x, b.y, 5, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.fillStyle = "red";
  for (const b of eBullets) {
    ctx.beginPath();
    ctx.arc(b.x, b.y, 5, 0, Math.PI * 2);
    ctx.fill();
  }

  // 적
  ctx.fillStyle = "red";
  ctx.beginPath();
  ctx.arc(enemy.x, enemy.y, enemy.r, 0, Math.PI * 2);
  ctx.fill();
  drawHp(enemy);

  // 플레이어
  ctx.fillStyle = "lime";
  ctx.beginPath();
  ctx.arc(player.x, player.y, player.r, 0, Math.PI * 2);
  ctx.fill();
  drawHp(player);

  ctx.restore();
}

function drawHp(obj) {
  ctx.fillStyle = "black";
  ctx.fillRect(obj.x - 20, obj.y - 30, 40, 6);
  ctx.fillStyle = "lime";
  ctx.fillRect(obj.x - 20, obj.y - 30, 40 * (obj.hp / 100), 6);
}

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}
loop();

window.addEventListener('resize', () => {
  W = window.innerWidth;
  H = window.innerHeight;
  canvas.width = W;
  canvas.height = H;
});
</script>
</body>
</html>
