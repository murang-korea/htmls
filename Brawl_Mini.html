<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>Brawl Mini</title>
<style>
  body { margin: 0; overflow: hidden; background: #222; touch-action: none; }
  canvas { display: block; background: #333; }
  .joystick {
    position: fixed;
    width: 120px; height: 120px;
    border-radius: 50%;
    background: rgba(255,255,255,0.1);
    border: 2px solid rgba(255,255,255,0.3);
    touch-action: none;
    z-index: 10;
  }
  .stick {
    position: absolute;
    width: 50px; height: 50px;
    background: rgba(255,255,255,0.3);
    border-radius: 50%;
    left: 35px; top: 35px;
  }
  #moveJoy { left: 30px; bottom: 30px; }
  #aimJoy { right: 30px; bottom: 30px; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="moveJoy" class="joystick"><div class="stick"></div></div>
<div id="aimJoy" class="joystick"><div class="stick"></div></div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let W = innerWidth, H = innerHeight;
canvas.width = W; canvas.height = H;

const player = { x: 0, y: 0, r: 20, hp: 100, reload: 0 };
const enemy = { x: 300, y: -400, r: 20, hp: 100, reload: 0 };
const bullets = [], eBullets = [], walls = [];
const mapW = 1200, mapH = 2000;
let moveVec = { x: 0, y: 0 }, aimVec = { x: 0, y: 0 };
let gameOver = false;

// 일정한 벽 생성
for (let i=0;i<10;i++){
  for (let j=0;j<4;j++){
    if((i+j)%2===0) walls.push({x:-mapW/2+150*i,y:-mapH/2+200*j,w:60,h:60});
  }
}

// ===== 멀티터치 조이스틱 =====
function setupJoystick(id, callback) {
  const joy = document.getElementById(id);
  const stick = joy.querySelector('.stick');
  let active = false, touchId = null, start = {x:0,y:0};

  joy.addEventListener('touchstart', e => {
    for (const t of e.changedTouches) {
      if (!active) {
        active = true;
        touchId = t.identifier;
        start.x = t.clientX; start.y = t.clientY;
      }
    }
  });

  joy.addEventListener('touchmove', e => {
    if (!active) return;
    for (const t of e.changedTouches) {
      if (t.identifier === touchId) {
        const dx = t.clientX - start.x;
        const dy = t.clientY - start.y;
        const dist = Math.min(40, Math.hypot(dx, dy));
        const ang = Math.atan2(dy, dx);
        stick.style.left = 35 + dist * Math.cos(ang) + 'px';
        stick.style.top = 35 + dist * Math.sin(ang) + 'px';
        callback(Math.cos(ang) * dist/40, Math.sin(ang)*dist/40);
      }
    }
  });

  joy.addEventListener('touchend', e => {
    for (const t of e.changedTouches) {
      if (t.identifier === touchId) {
        active = false;
        touchId = null;
        stick.style.left = '35px'; stick.style.top = '35px';
        callback(0,0);
      }
    }
  });
}

setupJoystick('moveJoy', (x,y)=>moveVec={x,y});
setupJoystick('aimJoy', (x,y)=>aimVec={x,y});

// ===== 게임 =====
function update(){
  if(gameOver)return;
  // 이동
  player.x += moveVec.x*3; player.y += moveVec.y*3;
  player.x = Math.max(-mapW/2+player.r, Math.min(mapW/2-player.r, player.x));
  player.y = Math.max(-mapH/2+player.r, Math.min(mapH/2-player.r, player.y));

  // 플레이어 발사
  if((aimVec.x||aimVec.y)&&player.reload<=0){
    bullets.push({x:player.x,y:player.y,dx:aimVec.x*8,dy:aimVec.y*8});
    player.reload=20;
  }
  if(player.reload>0)player.reload--;

  // 적 AI
  const dx=player.x-enemy.x, dy=player.y-enemy.y, dist=Math.hypot(dx,dy);
  if(dist>150){enemy.x+=(dx/dist)*1.2; enemy.y+=(dy/dist)*1.2;}
  if(enemy.reload<=0){
    eBullets.push({x:enemy.x,y:enemy.y,dx:(dx/dist)*6,dy:(dy/dist)*6});
    enemy.reload=50;
  }
  if(enemy.reload>0)enemy.reload--;

  // 총알 이동/충돌
  for(const b of bullets){
    b.x+=b.dx; b.y+=b.dy;
    if(hit(enemy,b,enemy.r)){enemy.hp-=10; b.dead=true;}
    if(walls.some(w=>collideRect(b,w)))b.dead=true;
  }
  for(const b of eBullets){
    b.x+=b.dx; b.y+=b.dy;
    if(hit(player,b,player.r)){player.hp-=10; b.dead=true;}
    if(walls.some(w=>collideRect(b,w)))b.dead=true;
  }
  bullets.splice(0,bullets.length,...bullets.filter(b=>!b.dead));
  eBullets.splice(0,eBullets.length,...eBullets.filter(b=>!b.dead));

  if(player.hp<=0||enemy.hp<=0){
    gameOver=true;
    setTimeout(()=>alert(player.hp>0?"승리!":"패배..."),300);
  }
}
function hit(a,b,r){return (a.x-b.x)**2+(a.y-b.y)**2<r**2;}
function collideRect(b,w){
  return b.x>w.x-w.w/2&&b.x<w.x+w.w/2&&b.y>w.y-w.h/2&&b.y<w.y+w.h/2;
}

function draw(){
  ctx.clearRect(0,0,W,H);
  const camX=player.x, camY=player.y;
  ctx.save(); ctx.translate(W/2-camX,H/2-camY);
  ctx.fillStyle="#444";
  ctx.fillRect(-mapW/2,-mapH/2,mapW,mapH);
  ctx.fillStyle="#666";
  for(const w of walls)ctx.fillRect(w.x-w.w/2,w.y-w.h/2,w.w,w.h);

  ctx.fillStyle="yellow";
  for(const b of bullets){ctx.beginPath();ctx.arc(b.x,b.y,5,0,Math.PI*2);ctx.fill();}
  ctx.fillStyle="red";
  for(const b of eBullets){ctx.beginPath();ctx.arc(b.x,b.y,5,0,Math.PI*2);ctx.fill();}

  ctx.fillStyle="red"; ctx.beginPath();ctx.arc(enemy.x,enemy.y,enemy.r,0,Math.PI*2);ctx.fill();
  drawHp(enemy);
  ctx.fillStyle="lime"; ctx.beginPath();ctx.arc(player.x,player.y,player.r,0,Math.PI*2);ctx.fill();
  drawHp(player);
  ctx.restore();
}
function drawHp(o){
  ctx.fillStyle="black";ctx.fillRect(o.x-20,o.y-30,40,6);
  ctx.fillStyle="lime";ctx.fillRect(o.x-20,o.y-30,40*(o.hp/100),6);
}

function loop(){update();draw();requestAnimationFrame(loop);}
loop();

window.addEventListener('resize',()=>{W=innerWidth;H=innerHeight;canvas.width=W;canvas.height=H;});
</script>
</body>
</html>
