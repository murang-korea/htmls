<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>patrol</title>
<style>
  :root {
    --bg:#0f1724; --floor:#111827; --wall:#374151;
    --player:#34d399; --guard:#fb7185;
  }
  html,body {margin:0;height:100%;background:var(--bg);overflow:hidden;}
  canvas {display:block;width:100vw;height:100vh;background:var(--floor);}
  .joy-wrap{position:fixed;left:50%;transform:translateX(-50%);bottom:18px;z-index:30}
  .joystick{width:120px;height:120px;border-radius:50%;background:rgba(255,255,255,0.05);
    border:2px solid rgba(255,255,255,0.08);position:relative;touch-action:none;}
  .stick{width:52px;height:52px;border-radius:50%;background:rgba(255,255,255,0.25);
    position:absolute;left:34px;top:34px;}
  #msg {
    position:fixed;inset:0;display:flex;align-items:center;justify-content:center;
    color:white;font-size:3rem;background:rgba(0,0,0,0.75);z-index:99;opacity:0;transition:opacity 0.6s;
  }
  #msg.show {opacity:1;}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="msg">GAME OVER</div>
<div class="joy-wrap"><div id="joy" class="joystick"><div id="stick" class="stick"></div></div></div>

<script>
const canvas=document.getElementById('c'),ctx=canvas.getContext('2d');
let W=innerWidth,H=innerHeight;canvas.width=W;canvas.height=H;

const TILE=48,COLS=18,ROWS=12;
const MAP_W=COLS*TILE,MAP_H=ROWS*TILE;
let grid=[];

// ---------------------------
// 랜덤 맵 생성
// ---------------------------
function genRandomMap(){
  grid=Array.from({length:ROWS},()=>Array(COLS).fill(0));
  // 테두리 벽
  for(let x=0;x<COLS;x++){grid[0][x]=1;grid[ROWS-1][x]=1;}
  for(let y=0;y<ROWS;y++){grid[y][0]=1;grid[y][COLS-1]=1;}

  // 무작위 벽 배치
  for(let y=1;y<ROWS-1;y++){
    for(let x=1;x<COLS-1;x++){
      if(Math.random()<0.18) grid[y][x]=1;
    }
  }

  // 랜덤 방 제거 (통로 확보)
  for(let i=0;i<20;i++){
    const rx=Math.floor(Math.random()*COLS);
    const ry=Math.floor(Math.random()*ROWS);
    for(let dy=-1;dy<=1;dy++){
      for(let dx=-1;dx<=1;dx++){
        const nx=rx+dx,ny=ry+dy;
        if(nx>0&&ny>0&&nx<COLS-1&&ny<ROWS-1) grid[ny][nx]=0;
      }
    }
  }
}
genRandomMap();

function w2t(wx,wy){return {tx:Math.floor((wx+MAP_W/2)/TILE),ty:Math.floor((wy+MAP_H/2)/TILE)};}
function t2w(tx,ty){return {x:tx*TILE+TILE/2-MAP_W/2,y:ty*TILE+TILE/2-MAP_H/2};}

const player={x:0,y:0,r:14,spd:2.4,dir:0,fov:120,range:240};
const guard={x:0,y:0,r:16,spd:1.4,dir:0,fov:100,range:240,chasing:false};

// ---------------------------
// 안전 스폰
// ---------------------------
function randomSpawn(entity){
  let tries=0;
  while(tries<500){
    const tx=Math.floor(Math.random()*COLS);
    const ty=Math.floor(Math.random()*ROWS);
    if(grid[ty][tx]===0){
      const {x,y}=t2w(tx,ty);
      entity.x=x;entity.y=y;
      if(!collide(entity.x,entity.y,entity.r))return;
    }
    tries++;
  }
}

// ---------------------------
// 충돌 감지
// ---------------------------
function collide(x,y,r){
  const {tx,ty}=w2t(x,y);
  for(let dy=-1;dy<=1;dy++)for(let dx=-1;dx<=1;dx++){
    const xx=tx+dx,yy=ty+dy;if(xx<0||yy<0||xx>=COLS||yy>=ROWS)continue;
    if(grid[yy][xx]){
      const wx=xx*TILE+TILE/2-MAP_W/2,wy=yy*TILE+TILE/2-MAP_H/2;
      const rx=wx-TILE/2,ry=wy-TILE/2;
      const testX=Math.max(rx,Math.min(x,rx+TILE));
      const testY=Math.max(ry,Math.min(y,ry+TILE));
      const dx0=x-testX,dy0=y-testY;
      if(dx0*dx0+dy0*dy0<r*r)return true;
    }
  }return false;
}

function rayBlocked(ax,ay,bx,by,step=6){
  const dx=bx-ax,dy=by-ay,L=Math.hypot(dx,dy);
  const nx=dx/L,ny=dy/L;let t=0;
  while(t<L){
    const px=ax+nx*t,py=ay+ny*t;
    const {tx,ty}=w2t(px,py);
    if(tx>=0&&tx<COLS&&ty>=0&&ty<ROWS&&grid[ty][tx])return true;
    t+=step;
  }
  return false;
}

function drawFOVMask(px,py,dir,fov,range){
  const mask=ctx.createRadialGradient(px,py,0,px,py,range);
  mask.addColorStop(0,'rgba(0,0,0,0)');
  mask.addColorStop(1,'rgba(0,0,0,1)');
  ctx.save();
  ctx.beginPath();ctx.rect(-MAP_W/2,-MAP_H/2,MAP_W,MAP_H);
  ctx.moveTo(px,py);
  const rays=[];const step=fov/60;
  for(let a=-fov/2;a<=fov/2;a+=step){
    const ang=(dir+a)*Math.PI/180;
    let ex=px+Math.cos(ang)*range,ey=py+Math.sin(ang)*range;
    for(let d=0;d<range;d+=6){
      const xx=px+Math.cos(ang)*d,yy=py+Math.sin(ang)*d;
      if(rayBlocked(px,py,xx,yy,4)){ex=xx;ey=yy;break;}
    }
    rays.push({x:ex,y:ey});
  }
  ctx.moveTo(px,py);for(const p of rays)ctx.lineTo(p.x,p.y);
  ctx.closePath();ctx.clip();
  ctx.fillStyle=mask;ctx.fillRect(-MAP_W/2,-MAP_H/2,MAP_W,MAP_H);
  ctx.restore();
}

function drawGuardFOV(x,y,dir,fov,range){
  const rays=[];const step=fov/50;
  for(let a=-fov/2;a<=fov/2;a+=step){
    const ang=(dir+a)*Math.PI/180;
    let ex=x+Math.cos(ang)*range,ey=y+Math.sin(ang)*range;
    for(let d=0;d<range;d+=6){
      const px=x+Math.cos(ang)*d,py=y+Math.sin(ang)*d;
      if(rayBlocked(x,y,px,py,4)){ex=px;ey=yy;break;}
    }
    rays.push({x:ex,y:ey});
  }
  ctx.beginPath();ctx.moveTo(x,y);
  for(const p of rays)ctx.lineTo(p.x,p.y);
  ctx.closePath();ctx.fillStyle="rgba(251,113,133,0.15)";ctx.fill();
}

/* 조이스틱 */
const joy=document.getElementById('joy'),stick=document.getElementById('stick');
let move={x:0,y:0},drag=false;
joy.addEventListener('touchstart',()=>drag=true,{passive:false});
joy.addEventListener('touchmove',e=>{
  if(!drag)return;
  const t=e.touches[0],r=joy.getBoundingClientRect();
  const cx=r.left+r.width/2,cy=r.top+r.height/2;
  const dx=t.clientX-cx,dy=t.clientY-cy;
  const dist=Math.min(40,Math.hypot(dx,dy));
  const ang=Math.atan2(dy,dx);
  stick.style.transform=`translate(${Math.cos(ang)*dist}px,${Math.sin(ang)*dist}px)`;
  move.x=Math.cos(ang)*(dist/40);move.y=Math.sin(ang)*(dist/40);
  player.dir=ang*180/Math.PI;
  e.preventDefault();
},{passive:false});
joy.addEventListener('touchend',()=>{drag=false;stick.style.transform='translate(0,0)';move={x:0,y:0};});

/* 게임 시작 */
randomSpawn(player);
randomSpawn(guard);
let gameOver=false;

function update(){
  if(gameOver)return;
  const nx=player.x+move.x*player.spd,ny=player.y+move.y*player.spd;
  if(!collide(nx,player.y,player.r))player.x=nx;
  if(!collide(player.x,ny,player.r))player.y=ny;

  const dx=player.x-guard.x,dy=player.y-guard.y;
  const dist=Math.hypot(dx,dy);
  const angleToPlayer=Math.atan2(dy,dx)*180/Math.PI;
  const diffAngle=((angleToPlayer-guard.dir+540)%360)-180;

  const seesPlayer = dist<guard.range && Math.abs(diffAngle)<guard.fov/2 && !rayBlocked(guard.x,guard.y,player.x,player.y);
  
  if(seesPlayer){
    guard.chasing=true;
    guard.spd=6;
    guard.dir=angleToPlayer;
  } else {
    guard.chasing=false;
    guard.spd=1.2;
    guard.dir+=0.5;
  }

  const gx=guard.x+Math.cos(guard.dir*Math.PI/180)*guard.spd;
  const gy=guard.y+Math.sin(guard.dir*Math.PI/180)*guard.spd;
  if(!collide(gx,gy,guard.r)){guard.x=gx;guard.y=gy;}

  if(Math.hypot(player.x-guard.x,player.y-guard.y)<player.r+guard.r){
    gameOver=true;document.getElementById('msg').classList.add('show');
  }
}

function draw(){
  ctx.clearRect(0,0,W,H);
  ctx.save();ctx.translate(W/2-player.x,H/2-player.y);
  ctx.fillStyle="#1e293b";ctx.fillRect(-MAP_W/2,-MAP_H/2,MAP_W,MAP_H);
  for(let y=0;y<ROWS;y++)for(let x=0;x<COLS;x++){
    if(grid[y][x]){
      const wx=x*TILE+TILE/2-MAP_W/2,wy=y*TILE+TILE/2-MAP_H/2;
      ctx.fillStyle="#374151";ctx.fillRect(wx-TILE/2,wy-TILE/2,TILE,TILE);
    }
  }
  drawGuardFOV(guard.x,guard.y,guard.dir,guard.fov,guard.range);
  ctx.fillStyle=guard.chasing?"#f87171":"#ef4444";
  ctx.beginPath();ctx.arc(guard.x,guard.y,16,0,Math.PI*2);ctx.fill();
  ctx.fillStyle="#34d399";ctx.beginPath();ctx.arc(player.x,player.y,14,0,Math.PI*2);ctx.fill();
  drawFOVMask(player.x,player.y,player.dir,player.fov,player.range);
  ctx.restore();
}

function loop(){update();draw();requestAnimationFrame(loop);}
loop();
window.addEventListener('resize',()=>{W=innerWidth;H=innerHeight;canvas.width=W;canvas.height=H;});
</script>
</body>
</html>
