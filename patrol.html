<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no"/>
<title>Stealth Rush</title>
<style>
  :root{
    --bg:#0b1220; --floor:#0f1724; --wall:#334155; --player:#34d399; --enemy:#ef4444;
  }
  html,body{height:100%;margin:0;background:var(--bg);overflow:hidden;-webkit-tap-highlight-color: transparent;}
  canvas{display:block; width:100vw; height:100vh; background:var(--floor); touch-action:none;}
  /* joystick UI */
  .joystick {
    position: fixed;
    left: 16px;
    bottom: 16px;
    width: 120px; height: 120px;
    border-radius: 50%;
    background: rgba(255,255,255,0.04);
    border: 2px solid rgba(255,255,255,0.06);
    z-index: 40;
    touch-action: none;
  }
  .stick {
    position:absolute;
    left:34px; top:34px;
    width:52px; height:52px; border-radius:50%;
    background: rgba(255,255,255,0.22);
    transition: transform 0.02s;
    touch-action: none;
  }
  /* message overlay */
  #msg {
    position: fixed; inset:0; display:flex; align-items:center; justify-content:center;
    z-index:60; pointer-events:none; opacity:0; transition:opacity .25s;
    color:#fff; font-size:28px; text-align:center;
  }
  #msg.show{opacity:1; pointer-events:auto; background: rgba(0,0,0,0.6);}
  /* responsive */
  @media (max-width:420px){
    .joystick{width:96px;height:96px}
    .stick{left:26px;top:26px;width:44px;height:44px}
  }
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<div class="joystick" id="joy"><div class="stick" id="stick"></div></div>
<div id="msg">GAME OVER<br><small>화면을 탭하면 재시작</small></div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { alpha: false });
let W = window.innerWidth, H = window.innerHeight;
canvas.width = W; canvas.height = H;

const TILE = 48, COLS = 18, ROWS = 12;
const MAP_W = COLS*TILE, MAP_H = ROWS*TILE;
let grid = [];

/* ---------- MAP GENERATION ---------- */
function genMap(){
  grid = Array.from({length:ROWS},()=>Array.from({length:COLS},()=>0));
  for(let x=0;x<COLS;x++){ grid[0][x]=1; grid[ROWS-1][x]=1; }
  for(let y=0;y<ROWS;y++){ grid[y][0]=1; grid[y][COLS-1]=1; }
  for(let y=1;y<ROWS-1;y++){
    for(let x=1;x<COLS-1;x++){
      if(Math.random()<0.18) grid[y][x]=1;
    }
  }
  for(let i=0;i<30;i++){
    const rx=Math.floor(Math.random()*(COLS-2))+1;
    const ry=Math.floor(Math.random()*(ROWS-2))+1;
    for(let dy=-1;dy<=1;dy++)for(let dx=-1;dx<=1;dx++){
      const nx=rx+dx, ny=ry+dy;
      if(nx>0&&ny>0&&nx<COLS-1&&ny<ROWS-1)grid[ny][nx]=0;
    }
  }
}

/* ---------- HELPERS ---------- */
function tileToWorld(tx,ty){ return {x:tx*TILE+TILE/2, y:ty*TILE+TILE/2}; }
function worldToTile(wx,wy){ return {tx:Math.floor(wx/TILE), ty:Math.floor(wy/TILE)}; }

function collidesAt(x,y,r){
  const {tx,ty}=worldToTile(x,y);
  for(let dy=-1;dy<=1;dy++)for(let dx=-1;dx<=1;dx++){
    const nx=tx+dx, ny=ty+dy;
    if(nx<0||ny<0||nx>=COLS||ny>=ROWS)continue;
    if(grid[ny][nx]===1){
      const rx=nx*TILE, ry=ny*TILE;
      const cx=Math.max(rx,Math.min(x,rx+TILE));
      const cy=Math.max(ry,Math.min(y,ry+TILE));
      const dx0=x-cx, dy0=y-cy;
      if(dx0*dx0+dy0*dy0<r*r)return true;
    }
  }
  return false;
}
function rayBlocked(ax,ay,bx,by,step=6){
  const dx=bx-ax, dy=by-ay, L=Math.hypot(dx,dy);
  const nx=dx/L, ny=dy/L;
  for(let t=0;t<L;t+=step){
    const px=ax+nx*t, py=ay+ny*t;
    const {tx,ty}=worldToTile(px,py);
    if(tx<0||ty<0||tx>=COLS||ty>=ROWS)return true;
    if(grid[ty][tx]===1)return true;
  }
  return false;
}

/* ---------- ENTITIES ---------- */
const player={x:0,y:0,r:14,spd:2.6,dir:-90,fov:120,range:220};
const enemy={x:0,y:0,r:16,spd:1.2,dir:0,fov:100,range:200,chasing:false};

function randomSpawn(ent){
  for(let i=0;i<1000;i++){
    const tx=Math.floor(Math.random()*(COLS-2))+1;
    const ty=Math.floor(Math.random()*(ROWS-2))+1;
    if(grid[ty][tx]===0){
      const {x,y}=tileToWorld(tx,ty);
      if(!collidesAt(x,y,ent.r)){ ent.x=x; ent.y=y; return true; }
    }
  }
  return false;
}

/* ---------- CONTROL ---------- */
let move={x:0,y:0}, dragging=false;
const joy=document.getElementById('joy'), stick=document.getElementById('stick');
joy.addEventListener('touchstart',()=>dragging=true);
joy.addEventListener('touchmove',e=>{
  if(!dragging)return;
  const t=e.touches[0]; const rect=joy.getBoundingClientRect();
  const cx=rect.left+rect.width/2, cy=rect.top+rect.height/2;
  const dx=t.clientX-cx, dy=t.clientY-cy;
  const dist=Math.min(Math.hypot(dx,dy),40);
  const ang=Math.atan2(dy,dx);
  stick.style.transform=`translate(${Math.cos(ang)*dist}px,${Math.sin(ang)*dist}px)`;
  move.x=Math.cos(ang)*(dist/40); move.y=Math.sin(ang)*(dist/40);
  player.dir=ang*180/Math.PI;
  e.preventDefault();
},{passive:false});
joy.addEventListener('touchend',()=>{dragging=false;stick.style.transform='translate(0,0)';move={x:0,y:0};});

/* ---------- GAME ---------- */
let gameOver=false; const msg=document.getElementById('msg');

function resetGame(){
  gameOver=false; msg.classList.remove('show');
  genMap();
  randomSpawn(player);
  do{ randomSpawn(enemy); }while(Math.hypot(player.x-enemy.x,player.y-enemy.y)<TILE*3);
  enemy.chasing=false; enemy.spd=1.2;
}

/* ---------- ENEMY LOGIC ---------- */
function enemyAI(){
  const dx=player.x-enemy.x, dy=player.y-enemy.y, dist=Math.hypot(dx,dy);
  const angleToPlayer=Math.atan2(dy,dx)*180/Math.PI;
  const angDiff=Math.abs(((angleToPlayer-enemy.dir+540)%360)-180);
  const sees=(dist<=enemy.range)&&(angDiff<=enemy.fov/2)&&(!rayBlocked(enemy.x,enemy.y,player.x,player.y,6));
  if(sees){
    enemy.chasing=true; enemy.spd=5; enemy.dir=angleToPlayer;
    const rad=enemy.dir*Math.PI/180;
    const ex=enemy.x+Math.cos(rad)*enemy.spd;
    const ey=enemy.y+Math.sin(rad)*enemy.spd;
    if(!collidesAt(ex,ey,enemy.r)){enemy.x=ex;enemy.y=ey;}
  }else{
    enemy.chasing=false; enemy.spd=1.2;
    enemy.dir+=0.3;
    const rad=enemy.dir*Math.PI/180;
    const nx=enemy.x+Math.cos(rad)*enemy.spd*0.6;
    const ny=enemy.y+Math.sin(rad)*enemy.spd*0.6;
    if(!collidesAt(nx,ny,enemy.r)){enemy.x=nx;enemy.y=ny;} else enemy.dir+=90;
  }
  if(dist<player.r+enemy.r){ gameOver=true; msg.classList.add('show'); }
}

/* ---------- DRAW ---------- */
function drawFOV(x,y,dirDeg,fovDeg,range,alpha=1){
  const sx=W/2+(x-player.x), sy=H/2+(y-player.y);
  const a0=(dirDeg-fovDeg/2)*Math.PI/180, a1=(dirDeg+fovDeg/2)*Math.PI/180;
  ctx.beginPath(); ctx.moveTo(sx,sy);
  const steps=60;
  for(let i=0;i<=steps;i++){
    const a=a0+(a1-a0)*(i/steps);
    let ex=x+Math.cos(a)*range, ey=y+Math.sin(a)*range;
    for(let d=0;d<range;d+=6){
      const wx=x+Math.cos(a)*d, wy=y+Math.sin(a)*d;
      const {tx,ty}=worldToTile(wx,wy);
      if(tx<0||ty<0||tx>=COLS||ty>=ROWS||grid[ty][tx]===1){ ex=wx; ey=wy; break; }
    }
    const screenX=W/2+(ex-player.x), screenY=H/2+(ey-player.y);
    ctx.lineTo(screenX,screenY);
  }
  ctx.closePath();
  const grad=ctx.createRadialGradient(sx,sy,0,sx,sy,range);
  grad.addColorStop(0,`rgba(255,255,255,${alpha})`);
  grad.addColorStop(1,'rgba(255,255,255,0)');
  ctx.fillStyle=grad; ctx.fill();
}

function draw(){
  ctx.clearRect(0,0,W,H);
  const camX=W/2-player.x, camY=H/2-player.y;
  ctx.save(); ctx.translate(camX,camY);
  for(let y=0;y<ROWS;y++)for(let x=0;x<COLS;x++){
    if(grid[y][x]===1){ ctx.fillStyle=varWall='#334155'; ctx.fillRect(x*TILE,y*TILE,TILE,TILE); }
  }
  ctx.fillStyle=enemy.chasing?'#ff7b7b':'#ef4444';
  ctx.beginPath(); ctx.arc(enemy.x,enemy.y,enemy.r,0,Math.PI*2); ctx.fill();
  ctx.fillStyle='#34d399';
  ctx.beginPath(); ctx.arc(player.x,player.y,player.r,0,Math.PI*2); ctx.fill();
  ctx.restore();

  // ---- 어둠 오버레이 + 시야 ----
  ctx.fillStyle='rgba(0,0,0,0.88)';
  ctx.fillRect(0,0,W,H);
  ctx.save();
  ctx.globalCompositeOperation='destination-out';
  drawFOV(player.x,player.y,player.dir,120,player.range,1);
  drawFOV(enemy.x,enemy.y,enemy.dir,120,enemy.range*0.8,0.25);
  ctx.restore();
}

/* ---------- UPDATE LOOP ---------- */
function update(){
  if(gameOver)return;
  const nx=player.x+move.x*player.spd, ny=player.y+move.y*player.spd;
  if(!collidesAt(nx,player.y,player.r))player.x=nx;
  if(!collidesAt(player.x,ny,player.r))player.y=ny;
  enemyAI();
}

function loop(){
  update(); draw(); requestAnimationFrame(loop);
}

/* ---------- INIT ---------- */
window.addEventListener('resize',()=>{W=window.innerWidth;H=window.innerHeight;canvas.width=W;canvas.height=H;});
window.addEventListener('touchstart',()=>{if(gameOver)resetGame();});
window.addEventListener('mousedown',()=>{if(gameOver)resetGame();});
resetGame(); loop();
</script>
</body>
</html>
