<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>테트리스 (버그 수정)</title>
<style>
  :root{--bg:#eef5ff;--panel:#fff}
  html,body{height:100%;margin:0;background:var(--bg);display:flex;align-items:center;justify-content:center;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Noto Sans',sans-serif}
  #wrap{display:flex;flex-direction:column;align-items:center;gap:8px}
  canvas{background:#111;border:4px solid #333;touch-action:none;display:block}
  .hud{display:flex;gap:12px;color:#222;font-weight:700}
  .overlay{position:fixed;left:0;top:0;right:0;bottom:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.5);color:#fff;font-size:20px;display:none}
  .btn{padding:6px 10px;border-radius:8px;background:#fff;border:0;cursor:pointer}
</style>
</head>
<body>
<div id="wrap">
  <canvas id="game" width="300" height="600"></canvas>
  <div class="hud">
    <div>점수: <span id="score">0</span></div>
    <div>레벨: <span id="level">1</span></div>
    <button id="restart" class="btn">재시작</button>
  </div>
</div>
<div id="overlay" class="overlay">
  <div id="overlayText"></div>
</div>

<script>
(() => {
  // 설정
  const COLS = 10, ROWS = 20, BLOCK = 30;
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  canvas.width = COLS * BLOCK;
  canvas.height = ROWS * BLOCK;

  const scoreEl = document.getElementById('score');
  const levelEl = document.getElementById('level');
  const overlay = document.getElementById('overlay');
  const overlayText = document.getElementById('overlayText');
  const restartBtn = document.getElementById('restart');

  // 4x4 통일된 테트로미노 (0 = 빈칸, 숫자는 채움값)
  const TETROMINO = [
    {m: [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]], color: '#00f0f0'}, // I
    {m: [[0,2,2,0],[0,2,2,0],[0,0,0,0],[0,0,0,0]], color: '#f0f000'}, // O
    {m: [[0,0,0,0],[0,3,0,0],[3,3,3,0],[0,0,0,0]], color: '#a000f0'}, // T
    {m: [[0,0,0,0],[0,4,4,0],[4,4,0,0],[0,0,0,0]], color: '#00f000'}, // S
    {m: [[0,0,0,0],[5,5,0,0],[0,5,5,0],[0,0,0,0]], color: '#f00000'}, // Z
    {m: [[0,0,6,0],[6,6,6,0],[0,0,0,0],[0,0,0,0]], color: '#0000f0'}, // J
    {m: [[7,0,0,0],[7,7,7,0],[0,0,0,0],[0,0,0,0]], color: '#f08a00'}  // L
  ];

  // 게임 상태
  let grid, current, pos, score, level, dropInterval, dropCounter, lastTime, gameOver;

  function resetGame() {
    grid = Array.from({length: ROWS}, () => Array(COLS).fill(0));
    score = 0; level = 1;
    dropInterval = 700;
    dropCounter = 0; lastTime = 0;
    gameOver = false;
    newPiece();
    updateHUD();
    overlay.style.display = 'none';
  }

  // 유틸: 깊은 복사
  function deepCopyMatrix(m){
    return m.map(row => row.slice());
  }

  // 새 블록 생성 (스폰 위치는 x=center-2, y = -1 으로 약간 위에서 시작)
  function newPiece(){
    const idx = Math.floor(Math.random() * TETROMINO.length);
    current = {
      matrix: deepCopyMatrix(TETROMINO[idx].m),
      color: TETROMINO[idx].color
    };
    pos = { x: Math.floor(COLS/2) - 2, y: -1 }; // 윗부분에서 시작
    // 즉시 스폰 충돌이면 게임오버
    if (collide(grid, current, pos)) {
      gameOver = true;
      showGameOver();
    }
  }

  // 충돌 체크: 블록의 채워진 칸이 그리드 밖(x범위, 아래) 또는 이미 채워진 칸과 겹치면 true
  function collide(g, piece, p) {
    const N = piece.matrix.length;
    for (let y = 0; y < N; y++) {
      for (let x = 0; x < N; x++) {
        if (!piece.matrix[y][x]) continue;
        const gx = p.x + x;
        const gy = p.y + y;
        // 좌우 범위 밖
        if (gx < 0 || gx >= COLS) return true;
        // 아래로 범위 밖 -> 충돌
        if (gy >= ROWS) return true;
        // 위쪽(음수)일땐 grid 검사 생략(스폰 중일 수 있음)
        if (gy >= 0 && g[gy][gx] !== 0) return true;
      }
    }
    return false;
  }

  // 블록을 그리드에 고정 (grid에 실제 값 쓰기) — grid 범위(gy>=0)만 쓰도록 함
  function lockPiece() {
    const N = current.matrix.length;
    for (let y = 0; y < N; y++) {
      for (let x = 0; x < N; x++) {
        if (!current.matrix[y][x]) continue;
        const gx = pos.x + x;
        const gy = pos.y + y;
        if (gy >= 0 && gy < ROWS && gx >=0 && gx < COLS) {
          grid[gy][gx] = current.matrix[y][x];
        }
      }
    }
  }

  // 한 줄 제거
  function sweep() {
    let lines = 0;
    outer: for (let y = ROWS - 1; y >= 0; y--) {
      for (let x = 0; x < COLS; x++) {
        if (grid[y][x] === 0) continue outer;
      }
      // 한 줄 제거
      const row = grid.splice(y,1)[0].fill(0);
      grid.unshift(row);
      lines++;
      y++;
    }
    if (lines > 0) {
      // 점수: 1줄=100, 2줄=300, 3줄=500, 4줄=800 (일반 테트리스 스코어 감각)
      const points = [0,100,300,500,800][lines] || (lines*200);
      score += points;
      // 레벨/속도 조절 간단하게
      level = Math.floor(score / 1000) + 1;
      dropInterval = Math.max(100, 700 - (level-1)*50);
    }
  }

  // 회전 (dir=1 오른쪽 / dir=-1 왼쪽) + 간단한 wall kick (좌우 오프셋 시도)
  function rotatePiece(dir) {
    const N = current.matrix.length;
    // rotate to new matrix
    const rotated = Array.from({length: N}, () => Array(N).fill(0));
    for (let y=0;y<N;y++){
      for (let x=0;x<N;x++){
        if (dir === 1) rotated[x][N-1-y] = current.matrix[y][x];
        else rotated[N-1-x][y] = current.matrix[y][x];
      }
    }
    const old = current.matrix;
    current.matrix = rotated;
    // try offsets for wall kick: 0, -1, +1, -2, +2
    const kicks = [0, -1, 1, -2, 2];
    for (let k of kicks) {
      pos.x += k;
      if (!collide(grid, current, pos)) return true;
      pos.x -= k;
    }
    // fail -> revert
    current.matrix = old;
    return false;
  }

  // 이동
  function move(dx) {
    pos.x += dx;
    if (collide(grid, current, pos)) pos.x -= dx;
  }

  // 소프트 드롭 / 하드 드롭
  function softDrop() {
    pos.y++;
    if (collide(grid, current, pos)) {
      pos.y--;
      lockPiece();
      sweep();
      newPiece();
    }
    dropCounter = 0;
  }
  function hardDrop() {
    while (!collide(grid, current, pos)) pos.y++;
    pos.y--;
    lockPiece();
    sweep();
    newPiece();
    dropCounter = 0;
  }

  // 그리기
  function draw() {
    // 배경
    ctx.fillStyle = '#111';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    // 그리드 칸
    for (let y=0;y<ROWS;y++){
      for (let x=0;x<COLS;x++){
        if (grid[y][x]) {
          ctx.fillStyle = colorFor(grid[y][x]);
          ctx.fillRect(x*BLOCK, y*BLOCK, BLOCK, BLOCK);
          ctx.strokeStyle = '#111'; ctx.lineWidth = 1; ctx.strokeRect(x*BLOCK,y*BLOCK,BLOCK,BLOCK);
        } else {
          // optional subtle grid lines
          ctx.strokeStyle = '#1b1b1b'; ctx.lineWidth = 0.5;
          ctx.strokeRect(x*BLOCK,y*BLOCK,BLOCK,BLOCK);
        }
      }
    }
    // 현재 블록
    const N = current.matrix.length;
    for (let y=0;y<N;y++){
      for (let x=0;x<N;x++){
        if (current.matrix[y][x]) {
          const gx = (pos.x + x) * BLOCK;
          const gy = (pos.y + y) * BLOCK;
          ctx.fillStyle = current.color;
          ctx.fillRect(gx, gy, BLOCK, BLOCK);
          ctx.strokeStyle = '#111'; ctx.lineWidth = 1; ctx.strokeRect(gx, gy, BLOCK, BLOCK);
        }
      }
    }
  }

  // 숫자 -> 색깔(간단 매핑)
  function colorFor(val){
    switch(val){
      case 1: return '#00f0f0';
      case 2: return '#f0f000';
      case 3: return '#a000f0';
      case 4: return '#00f000';
      case 5: return '#f00000';
      case 6: return '#0000f0';
      case 7: return '#f08a00';
      default: return '#888';
    }
  }

  // HUD / 오버레이 표시
  function updateHUD(){
    scoreEl.textContent = score;
    levelEl.textContent = level;
  }
  function showGameOver(){
    overlayText.textContent = '게임 오버\n재시작 버튼을 누르세요';
    overlay.style.display = 'flex';
  }

  // 게임 루프
  function update(time = 0) {
    if (gameOver) return;
    const delta = time - lastTime;
    lastTime = time;
    dropCounter += delta;
    if (dropCounter > dropInterval) {
      pos.y++;
      if (collide(grid, current, pos)) {
        pos.y--;
        lockPiece();
        sweep();
        newPiece();
      }
      dropCounter = 0;
    }
    draw();
    updateHUD();
    requestAnimationFrame(update);
  }

  // 입력 처리 (키보드)
  document.addEventListener('keydown', (e) => {
    if (gameOver) return;
    if (e.key === 'ArrowLeft') move(-1);
    else if (e.key === 'ArrowRight') move(1);
    else if (e.key === 'ArrowUp') rotatePiece(1);
    else if (e.key === 'ArrowDown') softDrop();
    else if (e.code === 'Space') { e.preventDefault(); hardDrop(); }
  });

  // 모바일 제스처 (스와이프 + 탭)
let touchStartX = 0, touchStartY = 0, touchTime = 0;
canvas.addEventListener('touchstart', e => {
  const t = e.touches[0];
  touchStartX = t.clientX;
  touchStartY = t.clientY;
  touchTime = Date.now();
}, {passive:true});

canvas.addEventListener('touchend', e => {
  const t = e.changedTouches[0];
  const dx = t.clientX - touchStartX;
  const dy = t.clientY - touchStartY;
  const dt = Date.now() - touchTime;

  // 탭(짧게 터치, 거의 움직이지 않음)
  if (Math.abs(dx) < 10 && Math.abs(dy) < 10 && dt < 200) {
    rotatePiece(1);
    return;
  }

  if (Math.abs(dx) > Math.abs(dy)) {
    if (dx > 20) move(1);       // 오른쪽 스와이프
    else if (dx < -20) move(-1); // 왼쪽 스와이프
  } else {
    if (dy > 20) softDrop();     // 아래 스와이프
    // 위로 스와이프는 동작 없음
  }
}, {passive:true});

  // 재시작 버튼
  restartBtn.addEventListener('click', () => {
    resetGame();
    requestAnimationFrame(update);
  });

  // 초기화 및 시작
  resetGame();
  requestAnimationFrame(update);

  // 외부에서 디버그용으로 접근 가능하게 (콘솔에서)
  window._td = { resetGame, grid };

})();
</script>
</body>
</html>
